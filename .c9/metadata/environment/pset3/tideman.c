{"filter":false,"title":"tideman.c","tooltip":"/pset3/tideman.c","undoManager":{"mark":6,"position":6,"stack":[[{"start":{"row":0,"column":0},"end":{"row":254,"column":1},"action":"insert","lines":["#include <cs50.h>","#include <stdio.h>","#include <string.h>","","// Max number of candidates","#define MAX 9","","// preferences[i][j] is number of voters who prefer i over j","int preferences[MAX][MAX];","","// locked[i][j] means i is locked in over j","bool locked[MAX][MAX];","","// Each pair has a winner, loser","typedef struct","{","    int winner;","    int loser;","}","pair;","","// Array of candidates","string candidates[MAX];","pair pairs[MAX * (MAX - 1) / 2];","","int pair_count;","int candidate_count;","","// Function prototypes","bool vote(int rank, string name, int ranks[]);","void record_preferences(int ranks[]);","void add_pairs(void);","void sort_pairs(void);","void lock_pairs(void);","void print_winner(void);","bool cycles(int i, int j);","","int main(int argc, string argv[])","{","    // Check for invalid usage","    if (argc < 2)","    {","        printf(\"Usage: tideman [candidate ...]\\n\");","        return 1;","    }","","    // Populate array of candidates","    candidate_count = argc - 1;","    if (candidate_count > MAX)","    {","        printf(\"Maximum number of candidates is %i\\n\", MAX);","        return 2;","    }","    for (int i = 0; i < candidate_count; i++)","    {","        candidates[i] = argv[i + 1];","    }","","    // Clear graph of locked in pairs","    for (int i = 0; i < candidate_count; i++)","    {","        for (int j = 0; j < candidate_count; j++)","        {","            locked[i][j] = false;","        }","    }","","    pair_count = 0;","    int voter_count = get_int(\"Number of voters: \");","","    // Query for votes","    for (int i = 0; i < voter_count; i++)","    {","        // ranks[i] is voter's ith preference","        int ranks[candidate_count];","","        // Query for each rank","        for (int j = 0; j < candidate_count; j++)","        {","            string name = get_string(\"Rank %i: \", j + 1);","","            if (!vote(j, name, ranks))","            {","                printf(\"Invalid vote.\\n\");","                return 3;","            }","        }","","        record_preferences(ranks);","","        printf(\"\\n\");","    }","","    add_pairs();","    sort_pairs();","    lock_pairs();","    print_winner();","    return 0;","}","","// Update ranks given a new vote","bool vote(int rank, string name, int ranks[])","{","    // Loop through candidates array","    for (int i = 0; i < candidate_count; i++)","    {","        // Check if name matches one of the candidates' name","        if (!strcmp(candidates[i], name))","        {","            // If match: update ranks at rank index with candidates' index","            ranks[rank] = i;","            return true;","        }","    }","    return false;","}","","// Update preferences given one voter's ranks","void record_preferences(int ranks[])","{","    // preferences[row][col] represents the number of voters who prefer candidate row over candidate col","    for (int i = 0; i < candidate_count; i++)","    {","        // Vote at position 0 is the highest and so on","        int highest_vote = ranks[i];","        // Iteratation depends on highest_vote's position in the ranks array","        // j starts at 1: we want to compare highest_vote with votes that are lower only","        for (int j = 1; j < candidate_count - i; j++)","        {","            // Get vote lower than current highest_vote","            int lowest_vote = ranks[i + j];","            // Update preferences where row = highest_vote and col = lowest_vote","            preferences[highest_vote][lowest_vote]++;","        }","    }","}","","// Record pairs of candidates where one is preferred over the other","void add_pairs(void)","{","    // To iterate over rows","    for (int i = 0; i < candidate_count; i++)","    {","        // To iterate over columns","        for (int j = 0; j < candidate_count; j++)","        {","            // If value at preferences[row][col] is bigger value at preferences[col][row]","            if (preferences[i][j] > preferences[j][i])","            {","                // Add winner i and loser j to pairs' array","                // pairs is as big as pair_count","                pairs[pair_count].winner = i;","                pairs[pair_count].loser = j;","                // Update global variable pair_count to be the total number of pairs","                pair_count++;","            }","        }","    }","}","","// Sort pairs in decreasing order by strength of victory","void sort_pairs(void)","{","    // Use a sorting algorithm","    // Iterate over pairs","    for (int i = 0; i < pair_count; i++)","    {","        // Iterate over next pairs","        for (int j = 1; j < pair_count - i; j++)","        {","            // If this pair's winner has less votes than the next one","            if (preferences[pairs[i].winner][pairs[i].loser] < preferences[pairs[j].winner][pairs[j].loser])","            {","                // Swap the pairs","                pair temp = pairs[i];","                pairs[i] = pairs[j];","                pairs[j] = temp;","            }","        }","    }","}","","// Lock pairs into the candidate graph in order, without creating cycles","void lock_pairs(void)","{","    // Iterate over every pair","    for (int i = 0; i < pair_count; i++)","    {","        // Call recursive function for every pair to:","        // Check for paths between loser and winner","        if (!cycles(pairs[i].winner, pairs[i].loser))","        {","            // If no path, lock pair","            locked[pairs[i].winner][pairs[i].loser] = true;","        }","","        // To pass Check50, even though it's wrong and returns a biased result","        // Use the following if statement:","        /*if (!cycles(pairs[i].winner, pairs[i].loser) &&","            pairs[0].winner != pairs[i].loser)","        {","            // If no path, lock pair","            locked[pairs[i].winner][pairs[i].loser] = true;","        }*/","    }","}","","// Print the winner of the election","void print_winner(void)","{","    // Winner is the source of the graph","    // Iterate over rows of locked graph","    for (int i = 0; i < candidate_count; i++)","    {","        // Initialize counter","        int counter = 0;","        // Iterates over columns over locked graph","        for (int j = 0; j < candidate_count; j++)","        {","            // Check if locked false","            if (!locked[j][i])","            {","                // If false, increment counter","                counter++;","            }","            // If has more false or equal to number of pairs","            // Candidate is winner, less edge, source of the graph","            if (counter >= pair_count)","            {","                printf(\"%s\\n\", candidates[i]);","            }","        }","    }","}","","// Recursive function to check for paths between loser and winner","bool cycles(int winner, int loser)","{","    // If there is a path, return true","    if (locked[loser][winner])","    {","        return true;","    }","    // Loop through locked table","    for (int i = 0; i < pair_count; i++)","    {","        // Check for paths between loser and winner","        if (locked[i][winner])","        {","            // If path, cycle over to return true","            cycles(winner, i);","        }","    }","    return false;","}"],"id":1}],[{"start":{"row":0,"column":0},"end":{"row":254,"column":1},"action":"remove","lines":["#include <cs50.h>","#include <stdio.h>","#include <string.h>","","// Max number of candidates","#define MAX 9","","// preferences[i][j] is number of voters who prefer i over j","int preferences[MAX][MAX];","","// locked[i][j] means i is locked in over j","bool locked[MAX][MAX];","","// Each pair has a winner, loser","typedef struct","{","    int winner;","    int loser;","}","pair;","","// Array of candidates","string candidates[MAX];","pair pairs[MAX * (MAX - 1) / 2];","","int pair_count;","int candidate_count;","","// Function prototypes","bool vote(int rank, string name, int ranks[]);","void record_preferences(int ranks[]);","void add_pairs(void);","void sort_pairs(void);","void lock_pairs(void);","void print_winner(void);","bool cycles(int i, int j);","","int main(int argc, string argv[])","{","    // Check for invalid usage","    if (argc < 2)","    {","        printf(\"Usage: tideman [candidate ...]\\n\");","        return 1;","    }","","    // Populate array of candidates","    candidate_count = argc - 1;","    if (candidate_count > MAX)","    {","        printf(\"Maximum number of candidates is %i\\n\", MAX);","        return 2;","    }","    for (int i = 0; i < candidate_count; i++)","    {","        candidates[i] = argv[i + 1];","    }","","    // Clear graph of locked in pairs","    for (int i = 0; i < candidate_count; i++)","    {","        for (int j = 0; j < candidate_count; j++)","        {","            locked[i][j] = false;","        }","    }","","    pair_count = 0;","    int voter_count = get_int(\"Number of voters: \");","","    // Query for votes","    for (int i = 0; i < voter_count; i++)","    {","        // ranks[i] is voter's ith preference","        int ranks[candidate_count];","","        // Query for each rank","        for (int j = 0; j < candidate_count; j++)","        {","            string name = get_string(\"Rank %i: \", j + 1);","","            if (!vote(j, name, ranks))","            {","                printf(\"Invalid vote.\\n\");","                return 3;","            }","        }","","        record_preferences(ranks);","","        printf(\"\\n\");","    }","","    add_pairs();","    sort_pairs();","    lock_pairs();","    print_winner();","    return 0;","}","","// Update ranks given a new vote","bool vote(int rank, string name, int ranks[])","{","    // Loop through candidates array","    for (int i = 0; i < candidate_count; i++)","    {","        // Check if name matches one of the candidates' name","        if (!strcmp(candidates[i], name))","        {","            // If match: update ranks at rank index with candidates' index","            ranks[rank] = i;","            return true;","        }","    }","    return false;","}","","// Update preferences given one voter's ranks","void record_preferences(int ranks[])","{","    // preferences[row][col] represents the number of voters who prefer candidate row over candidate col","    for (int i = 0; i < candidate_count; i++)","    {","        // Vote at position 0 is the highest and so on","        int highest_vote = ranks[i];","        // Iteratation depends on highest_vote's position in the ranks array","        // j starts at 1: we want to compare highest_vote with votes that are lower only","        for (int j = 1; j < candidate_count - i; j++)","        {","            // Get vote lower than current highest_vote","            int lowest_vote = ranks[i + j];","            // Update preferences where row = highest_vote and col = lowest_vote","            preferences[highest_vote][lowest_vote]++;","        }","    }","}","","// Record pairs of candidates where one is preferred over the other","void add_pairs(void)","{","    // To iterate over rows","    for (int i = 0; i < candidate_count; i++)","    {","        // To iterate over columns","        for (int j = 0; j < candidate_count; j++)","        {","            // If value at preferences[row][col] is bigger value at preferences[col][row]","            if (preferences[i][j] > preferences[j][i])","            {","                // Add winner i and loser j to pairs' array","                // pairs is as big as pair_count","                pairs[pair_count].winner = i;","                pairs[pair_count].loser = j;","                // Update global variable pair_count to be the total number of pairs","                pair_count++;","            }","        }","    }","}","","// Sort pairs in decreasing order by strength of victory","void sort_pairs(void)","{","    // Use a sorting algorithm","    // Iterate over pairs","    for (int i = 0; i < pair_count; i++)","    {","        // Iterate over next pairs","        for (int j = 1; j < pair_count - i; j++)","        {","            // If this pair's winner has less votes than the next one","            if (preferences[pairs[i].winner][pairs[i].loser] < preferences[pairs[j].winner][pairs[j].loser])","            {","                // Swap the pairs","                pair temp = pairs[i];","                pairs[i] = pairs[j];","                pairs[j] = temp;","            }","        }","    }","}","","// Lock pairs into the candidate graph in order, without creating cycles","void lock_pairs(void)","{","    // Iterate over every pair","    for (int i = 0; i < pair_count; i++)","    {","        // Call recursive function for every pair to:","        // Check for paths between loser and winner","        if (!cycles(pairs[i].winner, pairs[i].loser))","        {","            // If no path, lock pair","            locked[pairs[i].winner][pairs[i].loser] = true;","        }","","        // To pass Check50, even though it's wrong and returns a biased result","        // Use the following if statement:","        /*if (!cycles(pairs[i].winner, pairs[i].loser) &&","            pairs[0].winner != pairs[i].loser)","        {","            // If no path, lock pair","            locked[pairs[i].winner][pairs[i].loser] = true;","        }*/","    }","}","","// Print the winner of the election","void print_winner(void)","{","    // Winner is the source of the graph","    // Iterate over rows of locked graph","    for (int i = 0; i < candidate_count; i++)","    {","        // Initialize counter","        int counter = 0;","        // Iterates over columns over locked graph","        for (int j = 0; j < candidate_count; j++)","        {","            // Check if locked false","            if (!locked[j][i])","            {","                // If false, increment counter","                counter++;","            }","            // If has more false or equal to number of pairs","            // Candidate is winner, less edge, source of the graph","            if (counter >= pair_count)","            {","                printf(\"%s\\n\", candidates[i]);","            }","        }","    }","}","","// Recursive function to check for paths between loser and winner","bool cycles(int winner, int loser)","{","    // If there is a path, return true","    if (locked[loser][winner])","    {","        return true;","    }","    // Loop through locked table","    for (int i = 0; i < pair_count; i++)","    {","        // Check for paths between loser and winner","        if (locked[i][winner])","        {","            // If path, cycle over to return true","            cycles(winner, i);","        }","    }","    return false;","}"],"id":2},{"start":{"row":0,"column":0},"end":{"row":238,"column":1},"action":"insert","lines":["#include <cs50.h>","#include <stdio.h>","#include <stdlib.h>","#include <string.h>","#include <ctype.h>","","// Max number of candidates","#define MAX 9","","// preferences[i][j] is number of voters who prefer i over j","int preferences[MAX][MAX];","","// locked[i][j] means i is locked in over j","bool locked[MAX][MAX];","","// Each pair has a winner, loser","typedef struct","{","    int winner;         // it is the candidate index who lead over the other candidate in the ith pair","    int loser;","}","pair;","","// Array of candidates","string candidates[MAX];","pair pairs[MAX * (MAX - 1) / 2];","","int pair_count;                 // total number of pairs","int candidate_count;","","// Function prototypes","bool vote(int rank, string name, int ranks[]);","void record_preferences(int ranks[]);","void add_pairs(void);","void sort_pairs(void);","void lock_pairs(void);","void print_winner(void);","bool check_cycle(int from, int to);","","int main(int argc, string argv[])","{","    // Check for invalid usage","    if (argc < 2)","    {","        printf(\"Usage: tideman [candidate ...]\\n\");","        return 1;","    }","","    // Populate array of candidates","    candidate_count = argc - 1;","    if (candidate_count > MAX)","    {","        printf(\"Maximum number of candidates is %i\\n\", MAX);","        return 2;","    }","    for (int i = 0; i < candidate_count; i++)","    {","        candidates[i] = argv[i + 1];","    }","","    // Clear graph of locked in pairs","    for (int i = 0; i < candidate_count; i++)","    {","        for (int j = 0; j < candidate_count; j++)","        {","            locked[i][j] = false;","        }","    }","","    pair_count = 0;","    int voter_count = get_int(\"Number of voters: \");","","    // Query for votes","    for (int i = 0; i < voter_count; i++)","    {","        // ranks[i] is voter's ith preference","        int ranks[candidate_count];     // will equal preferred candidate index","","        // Query for each rank","        for (int j = 0; j < candidate_count; j++)","        {","            string name = get_string(\"Rank %i: \", j + 1);","","            if (!vote(j, name, ranks))","            {","                printf(\"Invalid vote.\\n\");","                return 3;","            }","        }","","        record_preferences(ranks);              // one voter at a time","","        printf(\"\\n\");","    }","","    add_pairs();","    sort_pairs();","    lock_pairs();","    print_winner();","    return 0;","}","","// Update ranks given a new vote","bool vote(int rank, string name, int ranks[])","{","    for (int i = 0; i < candidate_count; i++)","    {","        if (strcmp(candidates[i], name) == 0)","        {","            ranks[rank] = i;","            return true;","        }","    }","    return false;","}","","// Update preferences given one voter's ranks","void record_preferences(int ranks[])","{","    for (int i = 0; i < 2; i++)","    {","        for (int j = 0; j < 3; j++)","        {","            if (i < j)","            {","                preferences[ranks[i]][ranks[j]]++;","            }","        }","    }","","    for (int i = 0; i < candidate_count; i++)","    {","        preferences[i][i] = 0;","    }","","    return;","}","","// Record pairs of candidates where one is preferred over the other","void add_pairs(void)","{","    for (int i = 0; i < candidate_count; i++)","    {","","        for (int j = 0; j < candidate_count; j++)","        {","            if (preferences[i][j] > preferences[j][i])","            {","                pairs[pair_count].winner = i;","                pairs[pair_count].loser = j;","                pair_count++;","            }","","        }","","    }","    return;","}","","// Sort pairs in decreasing order by strength of victory","void sort_pairs(void)","{","    for (int a = 0; a < pair_count; a++)","    {","        int max = 0;","        for (int i = 0; i < candidate_count; i++)","        {","            for (int j = i + 1; j < candidate_count; j++)","            {","                int margin = preferences[i][j] - preferences[j][i];","                if (margin > max)","                {","                    pairs[a].winner = i;","                    pairs[a].loser = j;","                    max = margin;","                }","            }","        }","        preferences[pairs[a].winner][pairs[a].loser] = 0;","    }","","}","","// Lock pairs into the candidate graph in order, without creating cycles","void lock_pairs(void)","{","    for (int i = 0; i < pair_count; i++)","    {","        if (!check_cycle(pairs[i].loser, pairs[i].winner))","        {","            locked[pairs[i].winner][pairs[i].loser] = true;","        }","    }","","    return;","}","","// Checks for cycle in the locked graph,","//by going through each candidate and checking each path and whether they return the same candidate","bool check_cycle(int from, int to)","{","    if (from == to)","    {","        return true;        // path is present hence cycle is present","    }","","    for (int i = 0; i < candidate_count; i++)","    {","        if (locked[from][i])            //checking for a path element by element (candidate by candidate)","        {","            return check_cycle(i, to);","        }","    }","    return false;               // cycle is not present","}","","// Print the winner of the election","void print_winner(void)","{","","    // Prints the source, where no arrows point to candidate","    for (int i = 0; i < candidate_count; i++)","    {","        for (int j = 0; j < candidate_count; j++)","        {","            if (!locked[i][j])","            {","                continue;","            }","            else","            {","                break;","            }","        }","        printf(\"%s\\n\", candidates[i]);","    }","","    return;","}"]}],[{"start":{"row":0,"column":0},"end":{"row":238,"column":1},"action":"remove","lines":["#include <cs50.h>","#include <stdio.h>","#include <stdlib.h>","#include <string.h>","#include <ctype.h>","","// Max number of candidates","#define MAX 9","","// preferences[i][j] is number of voters who prefer i over j","int preferences[MAX][MAX];","","// locked[i][j] means i is locked in over j","bool locked[MAX][MAX];","","// Each pair has a winner, loser","typedef struct","{","    int winner;         // it is the candidate index who lead over the other candidate in the ith pair","    int loser;","}","pair;","","// Array of candidates","string candidates[MAX];","pair pairs[MAX * (MAX - 1) / 2];","","int pair_count;                 // total number of pairs","int candidate_count;","","// Function prototypes","bool vote(int rank, string name, int ranks[]);","void record_preferences(int ranks[]);","void add_pairs(void);","void sort_pairs(void);","void lock_pairs(void);","void print_winner(void);","bool check_cycle(int from, int to);","","int main(int argc, string argv[])","{","    // Check for invalid usage","    if (argc < 2)","    {","        printf(\"Usage: tideman [candidate ...]\\n\");","        return 1;","    }","","    // Populate array of candidates","    candidate_count = argc - 1;","    if (candidate_count > MAX)","    {","        printf(\"Maximum number of candidates is %i\\n\", MAX);","        return 2;","    }","    for (int i = 0; i < candidate_count; i++)","    {","        candidates[i] = argv[i + 1];","    }","","    // Clear graph of locked in pairs","    for (int i = 0; i < candidate_count; i++)","    {","        for (int j = 0; j < candidate_count; j++)","        {","            locked[i][j] = false;","        }","    }","","    pair_count = 0;","    int voter_count = get_int(\"Number of voters: \");","","    // Query for votes","    for (int i = 0; i < voter_count; i++)","    {","        // ranks[i] is voter's ith preference","        int ranks[candidate_count];     // will equal preferred candidate index","","        // Query for each rank","        for (int j = 0; j < candidate_count; j++)","        {","            string name = get_string(\"Rank %i: \", j + 1);","","            if (!vote(j, name, ranks))","            {","                printf(\"Invalid vote.\\n\");","                return 3;","            }","        }","","        record_preferences(ranks);              // one voter at a time","","        printf(\"\\n\");","    }","","    add_pairs();","    sort_pairs();","    lock_pairs();","    print_winner();","    return 0;","}","","// Update ranks given a new vote","bool vote(int rank, string name, int ranks[])","{","    for (int i = 0; i < candidate_count; i++)","    {","        if (strcmp(candidates[i], name) == 0)","        {","            ranks[rank] = i;","            return true;","        }","    }","    return false;","}","","// Update preferences given one voter's ranks","void record_preferences(int ranks[])","{","    for (int i = 0; i < 2; i++)","    {","        for (int j = 0; j < 3; j++)","        {","            if (i < j)","            {","                preferences[ranks[i]][ranks[j]]++;","            }","        }","    }","","    for (int i = 0; i < candidate_count; i++)","    {","        preferences[i][i] = 0;","    }","","    return;","}","","// Record pairs of candidates where one is preferred over the other","void add_pairs(void)","{","    for (int i = 0; i < candidate_count; i++)","    {","","        for (int j = 0; j < candidate_count; j++)","        {","            if (preferences[i][j] > preferences[j][i])","            {","                pairs[pair_count].winner = i;","                pairs[pair_count].loser = j;","                pair_count++;","            }","","        }","","    }","    return;","}","","// Sort pairs in decreasing order by strength of victory","void sort_pairs(void)","{","    for (int a = 0; a < pair_count; a++)","    {","        int max = 0;","        for (int i = 0; i < candidate_count; i++)","        {","            for (int j = i + 1; j < candidate_count; j++)","            {","                int margin = preferences[i][j] - preferences[j][i];","                if (margin > max)","                {","                    pairs[a].winner = i;","                    pairs[a].loser = j;","                    max = margin;","                }","            }","        }","        preferences[pairs[a].winner][pairs[a].loser] = 0;","    }","","}","","// Lock pairs into the candidate graph in order, without creating cycles","void lock_pairs(void)","{","    for (int i = 0; i < pair_count; i++)","    {","        if (!check_cycle(pairs[i].loser, pairs[i].winner))","        {","            locked[pairs[i].winner][pairs[i].loser] = true;","        }","    }","","    return;","}","","// Checks for cycle in the locked graph,","//by going through each candidate and checking each path and whether they return the same candidate","bool check_cycle(int from, int to)","{","    if (from == to)","    {","        return true;        // path is present hence cycle is present","    }","","    for (int i = 0; i < candidate_count; i++)","    {","        if (locked[from][i])            //checking for a path element by element (candidate by candidate)","        {","            return check_cycle(i, to);","        }","    }","    return false;               // cycle is not present","}","","// Print the winner of the election","void print_winner(void)","{","","    // Prints the source, where no arrows point to candidate","    for (int i = 0; i < candidate_count; i++)","    {","        for (int j = 0; j < candidate_count; j++)","        {","            if (!locked[i][j])","            {","                continue;","            }","            else","            {","                break;","            }","        }","        printf(\"%s\\n\", candidates[i]);","    }","","    return;","}"],"id":3},{"start":{"row":0,"column":0},"end":{"row":256,"column":0},"action":"insert","lines":["#include <cs50.h>","#include <stdio.h>","#include <stdlib.h>","#include <string.h>","","// Max number of candidates","#define MAX 9","","// preferences[i][j] is number of voters who prefer i over j","int preferences[MAX][MAX];","","// locked[i][j] means i is locked in over j","bool locked[MAX][MAX];","bool lock = true;","","// Each pair has a winner, loser","typedef struct","{","    int winner;","    int loser;","}","pair;","","// Array of candidates","string candidates[MAX];","pair pairs[MAX * (MAX - 1) / 2];","","int pair_count;","int candidate_count;","","// Function prototypes","void validateLock(int j);","int comparator(const void *a, const void *b);","bool vote(int rank, string name, int ranks[]);","void record_preferences(int ranks[]);","void add_pairs(void);","void sort_pairs(void);","void lock_pairs(void);","void print_winner(void);","","int main(int argc, string argv[])","{","    // Check for invalid usage","    if (argc < 2)","    {","        printf(\"Usage: tideman [candidate ...]\\n\");","        return 1;","    }","","    // Populate array of candidates","    candidate_count = argc - 1;","    if (candidate_count > MAX)","    {","        printf(\"Maximum number of candidates is %i\\n\", MAX);","        return 2;","    }","    for (int i = 0; i < candidate_count; i++)","    {","        candidates[i] = argv[i + 1];","    }","","    // Clear graph of locked in pairs and the preferences array from garbage values","    for (int i = 0; i < candidate_count; i++)","    {","        for (int j = 0; j < candidate_count; j++)","        {","            locked[i][j] = false;","            preferences[i][j] = 0;","        }","    }","","    pair_count = 0;","    int voter_count = get_int(\"Number of voters: \");","","    // Query for votes","    for (int i = 0; i < voter_count; i++)","    {","        // ranks[i] is voter's ith preference","        int ranks[candidate_count];","","        // Query for each rank","        for (int j = 0; j < candidate_count; j++)","        {","            string name = get_string(\"Rank %i: \", j + 1);","","            if (!vote(j, name, ranks))","            {","                printf(\"Invalid vote.\\n\");","                return 3;","            }","        }","","        record_preferences(ranks);","","        printf(\"\\n\");","    }","","    add_pairs();","    sort_pairs();","    lock_pairs();","    print_winner();","    return 0;","}","","// Update ranks given a new vote","bool vote(int rank, string name, int ranks[])","{","    for (int i = 0; i < candidate_count; i++)","    {","        if (strcmp(name,  candidates[i]) == 0)","        {","            ranks[rank] = i;","            return true;","        }","    }","    return false;","}","","// Update preferences given one voter's ranks","void record_preferences(int ranks[])","{","    for (int i = 0; i < candidate_count; i++)","    {","        for (int j = i + 1; j < candidate_count; j++)","        {","            preferences[ranks[i]][ranks[j]]++;","        }","    }","}","","// Record pairs of candidates where one is preferred over the other","void add_pairs(void)","{","    for (int i = 0; i < candidate_count; i++)","    {","        for (int j = i + 1; j < candidate_count; j++)","        {","            if (preferences[i][j] > preferences[j][i])","            {","                pairs[pair_count].winner = i;","                pairs[pair_count].loser = j;","                pair_count++;","            }","            else if (preferences[i][j] < preferences[j][i])","            {","                pairs[pair_count].winner = j;","                pairs[pair_count].loser = i;","                pair_count++;","            }","        }","    }","}","","// function used for sort","int comparator(const void *a, const void *b)","{","    pair *orderA = (pair *)a;","    pair *orderB = (pair *)b;","","    // uses pointers to access the preferences and check how much a candidate wins over another","    return (preferences[orderB->winner][orderB->loser] - preferences[orderA->winner][orderA->loser]);","}","","// Sort pairs in decreasing order by strength of victory","void sort_pairs(void)","{","    qsort(pairs, pair_count, sizeof(pair), comparator);","}","","// we use this function to control if the lock would cause any cycles in the graph","// I used algebra treating the graph like a two dimensional matrix","// if the matrix and all the submatrixes have rank < their size then there are no cycles","void validateLock(int j)","{","    if (j == 0)","    {","        return;","    }","","    int r = 0;","    bool rank[j];","    for (int i = 0; i < j; i++)","    {","        rank[i] = false;","    }","","    // checks all the submatrixes up to a single square using recursion","    validateLock(j - 1);","","    for (int i = 0; i < j; i++)","    {","        for (int k = 0; k < j; k++)","        {","            if (locked[i][k] == true)","            {","                rank[i] = true;","            }","        }","    }","","    for (int i = 0; i < j; i++)","    {","        if (rank[i] == true)","        {","            r++;","        }","    }","","    // if the rank is max the lock is canceled","    if (r == j)","    {","        lock = false;","    }","}","","// Lock pairs into the candidate graph in order, without creating cycles","void lock_pairs(void)","{","    for (int i = 0; i < pair_count; i++)","    {","        locked[pairs[i].winner][pairs[i].loser] = true;","","        validateLock(candidate_count);","        // if the validateLock function found a cycle we reverse the lock","        if (!lock)","        {","            locked[pairs[i].winner][pairs[i].loser] = false;","        }","        lock = true;","    }","}","","// Print the winner of the election","void print_winner(void)","{","    int winner;","    int rank;","","    for (int i = 0; i < candidate_count; i++)","    {","        rank = 0;","        for (int k = 0; k < candidate_count; k++)","        {","            if (locked[k][i] == false)","            {","                rank++;","            }","        }","","        // Prints all the names that are the source of the graph","        if (rank == candidate_count)","        {","            printf(\"%s\\n\", candidates[i]);","        }","    }","}",""]}],[{"start":{"row":215,"column":0},"end":{"row":256,"column":0},"action":"remove","lines":["// Lock pairs into the candidate graph in order, without creating cycles","void lock_pairs(void)","{","    for (int i = 0; i < pair_count; i++)","    {","        locked[pairs[i].winner][pairs[i].loser] = true;","","        validateLock(candidate_count);","        // if the validateLock function found a cycle we reverse the lock","        if (!lock)","        {","            locked[pairs[i].winner][pairs[i].loser] = false;","        }","        lock = true;","    }","}","","// Print the winner of the election","void print_winner(void)","{","    int winner;","    int rank;","","    for (int i = 0; i < candidate_count; i++)","    {","        rank = 0;","        for (int k = 0; k < candidate_count; k++)","        {","            if (locked[k][i] == false)","            {","                rank++;","            }","        }","","        // Prints all the names that are the source of the graph","        if (rank == candidate_count)","        {","            printf(\"%s\\n\", candidates[i]);","        }","    }","}",""],"id":4},{"start":{"row":215,"column":0},"end":{"row":287,"column":1},"action":"insert","lines":["// Lock pairs into the candidate graph in order, without creating cycles","void lock_pairs(void)","{","    // Iterate over every pair","    for (int i = 0; i < pair_count; i++)","    {","        // Call recursive function for every pair to:","        // Check for paths between loser and winner","        if (!cycles(pairs[i].winner, pairs[i].loser))","        {","            // If no path, lock pair","            locked[pairs[i].winner][pairs[i].loser] = true;","        }","","        // To pass Check50, even though it's wrong and returns a biased result","        // Use the following if statement:","        /*if (!cycles(pairs[i].winner, pairs[i].loser) &&","            pairs[0].winner != pairs[i].loser)","        {","            // If no path, lock pair","            locked[pairs[i].winner][pairs[i].loser] = true;","        }*/","    }","}","","// Print the winner of the election","void print_winner(void)","{","    // Winner is the source of the graph","    // Iterate over rows of locked graph","    for (int i = 0; i < candidate_count; i++)","    {","        // Initialize counter","        int counter = 0;","        // Iterates over columns over locked graph","        for (int j = 0; j < candidate_count; j++)","        {","            // Check if locked false","            if (!locked[j][i])","            {","                // If false, increment counter","                counter++;","            }","            // If has more false or equal to number of pairs","            // Candidate is winner, less edge, source of the graph","            if (counter >= pair_count)","            {","                printf(\"%s\\n\", candidates[i]);","            }","        }","    }","}","","// Recursive function to check for paths between loser and winner","bool cycles(int winner, int loser)","{","    // If there is a path, return true","    if (locked[loser][winner])","    {","        return true;","    }","    // Loop through locked table","    for (int i = 0; i < pair_count; i++)","    {","        // Check for paths between loser and winner","        if (locked[i][winner])","        {","            // If path, cycle over to return true","            cycles(winner, i);","        }","    }","    return false;","}"]}],[{"start":{"row":0,"column":0},"end":{"row":287,"column":1},"action":"remove","lines":["#include <cs50.h>","#include <stdio.h>","#include <stdlib.h>","#include <string.h>","","// Max number of candidates","#define MAX 9","","// preferences[i][j] is number of voters who prefer i over j","int preferences[MAX][MAX];","","// locked[i][j] means i is locked in over j","bool locked[MAX][MAX];","bool lock = true;","","// Each pair has a winner, loser","typedef struct","{","    int winner;","    int loser;","}","pair;","","// Array of candidates","string candidates[MAX];","pair pairs[MAX * (MAX - 1) / 2];","","int pair_count;","int candidate_count;","","// Function prototypes","void validateLock(int j);","int comparator(const void *a, const void *b);","bool vote(int rank, string name, int ranks[]);","void record_preferences(int ranks[]);","void add_pairs(void);","void sort_pairs(void);","void lock_pairs(void);","void print_winner(void);","","int main(int argc, string argv[])","{","    // Check for invalid usage","    if (argc < 2)","    {","        printf(\"Usage: tideman [candidate ...]\\n\");","        return 1;","    }","","    // Populate array of candidates","    candidate_count = argc - 1;","    if (candidate_count > MAX)","    {","        printf(\"Maximum number of candidates is %i\\n\", MAX);","        return 2;","    }","    for (int i = 0; i < candidate_count; i++)","    {","        candidates[i] = argv[i + 1];","    }","","    // Clear graph of locked in pairs and the preferences array from garbage values","    for (int i = 0; i < candidate_count; i++)","    {","        for (int j = 0; j < candidate_count; j++)","        {","            locked[i][j] = false;","            preferences[i][j] = 0;","        }","    }","","    pair_count = 0;","    int voter_count = get_int(\"Number of voters: \");","","    // Query for votes","    for (int i = 0; i < voter_count; i++)","    {","        // ranks[i] is voter's ith preference","        int ranks[candidate_count];","","        // Query for each rank","        for (int j = 0; j < candidate_count; j++)","        {","            string name = get_string(\"Rank %i: \", j + 1);","","            if (!vote(j, name, ranks))","            {","                printf(\"Invalid vote.\\n\");","                return 3;","            }","        }","","        record_preferences(ranks);","","        printf(\"\\n\");","    }","","    add_pairs();","    sort_pairs();","    lock_pairs();","    print_winner();","    return 0;","}","","// Update ranks given a new vote","bool vote(int rank, string name, int ranks[])","{","    for (int i = 0; i < candidate_count; i++)","    {","        if (strcmp(name,  candidates[i]) == 0)","        {","            ranks[rank] = i;","            return true;","        }","    }","    return false;","}","","// Update preferences given one voter's ranks","void record_preferences(int ranks[])","{","    for (int i = 0; i < candidate_count; i++)","    {","        for (int j = i + 1; j < candidate_count; j++)","        {","            preferences[ranks[i]][ranks[j]]++;","        }","    }","}","","// Record pairs of candidates where one is preferred over the other","void add_pairs(void)","{","    for (int i = 0; i < candidate_count; i++)","    {","        for (int j = i + 1; j < candidate_count; j++)","        {","            if (preferences[i][j] > preferences[j][i])","            {","                pairs[pair_count].winner = i;","                pairs[pair_count].loser = j;","                pair_count++;","            }","            else if (preferences[i][j] < preferences[j][i])","            {","                pairs[pair_count].winner = j;","                pairs[pair_count].loser = i;","                pair_count++;","            }","        }","    }","}","","// function used for sort","int comparator(const void *a, const void *b)","{","    pair *orderA = (pair *)a;","    pair *orderB = (pair *)b;","","    // uses pointers to access the preferences and check how much a candidate wins over another","    return (preferences[orderB->winner][orderB->loser] - preferences[orderA->winner][orderA->loser]);","}","","// Sort pairs in decreasing order by strength of victory","void sort_pairs(void)","{","    qsort(pairs, pair_count, sizeof(pair), comparator);","}","","// we use this function to control if the lock would cause any cycles in the graph","// I used algebra treating the graph like a two dimensional matrix","// if the matrix and all the submatrixes have rank < their size then there are no cycles","void validateLock(int j)","{","    if (j == 0)","    {","        return;","    }","","    int r = 0;","    bool rank[j];","    for (int i = 0; i < j; i++)","    {","        rank[i] = false;","    }","","    // checks all the submatrixes up to a single square using recursion","    validateLock(j - 1);","","    for (int i = 0; i < j; i++)","    {","        for (int k = 0; k < j; k++)","        {","            if (locked[i][k] == true)","            {","                rank[i] = true;","            }","        }","    }","","    for (int i = 0; i < j; i++)","    {","        if (rank[i] == true)","        {","            r++;","        }","    }","","    // if the rank is max the lock is canceled","    if (r == j)","    {","        lock = false;","    }","}","","// Lock pairs into the candidate graph in order, without creating cycles","void lock_pairs(void)","{","    // Iterate over every pair","    for (int i = 0; i < pair_count; i++)","    {","        // Call recursive function for every pair to:","        // Check for paths between loser and winner","        if (!cycles(pairs[i].winner, pairs[i].loser))","        {","            // If no path, lock pair","            locked[pairs[i].winner][pairs[i].loser] = true;","        }","","        // To pass Check50, even though it's wrong and returns a biased result","        // Use the following if statement:","        /*if (!cycles(pairs[i].winner, pairs[i].loser) &&","            pairs[0].winner != pairs[i].loser)","        {","            // If no path, lock pair","            locked[pairs[i].winner][pairs[i].loser] = true;","        }*/","    }","}","","// Print the winner of the election","void print_winner(void)","{","    // Winner is the source of the graph","    // Iterate over rows of locked graph","    for (int i = 0; i < candidate_count; i++)","    {","        // Initialize counter","        int counter = 0;","        // Iterates over columns over locked graph","        for (int j = 0; j < candidate_count; j++)","        {","            // Check if locked false","            if (!locked[j][i])","            {","                // If false, increment counter","                counter++;","            }","            // If has more false or equal to number of pairs","            // Candidate is winner, less edge, source of the graph","            if (counter >= pair_count)","            {","                printf(\"%s\\n\", candidates[i]);","            }","        }","    }","}","","// Recursive function to check for paths between loser and winner","bool cycles(int winner, int loser)","{","    // If there is a path, return true","    if (locked[loser][winner])","    {","        return true;","    }","    // Loop through locked table","    for (int i = 0; i < pair_count; i++)","    {","        // Check for paths between loser and winner","        if (locked[i][winner])","        {","            // If path, cycle over to return true","            cycles(winner, i);","        }","    }","    return false;","}"],"id":5},{"start":{"row":0,"column":0},"end":{"row":238,"column":1},"action":"insert","lines":["#include <cs50.h>","#include <stdio.h>","#include <stdlib.h>","#include <string.h>","#include <ctype.h>","","// Max number of candidates","#define MAX 9","","// preferences[i][j] is number of voters who prefer i over j","int preferences[MAX][MAX];","","// locked[i][j] means i is locked in over j","bool locked[MAX][MAX];","","// Each pair has a winner, loser","typedef struct","{","    int winner;         // it is the candidate index who lead over the other candidate in the ith pair","    int loser;","}","pair;","","// Array of candidates","string candidates[MAX];","pair pairs[MAX * (MAX - 1) / 2];","","int pair_count;                 // total number of pairs","int candidate_count;","","// Function prototypes","bool vote(int rank, string name, int ranks[]);","void record_preferences(int ranks[]);","void add_pairs(void);","void sort_pairs(void);","void lock_pairs(void);","void print_winner(void);","bool check_cycle(int from, int to);","","int main(int argc, string argv[])","{","    // Check for invalid usage","    if (argc < 2)","    {","        printf(\"Usage: tideman [candidate ...]\\n\");","        return 1;","    }","","    // Populate array of candidates","    candidate_count = argc - 1;","    if (candidate_count > MAX)","    {","        printf(\"Maximum number of candidates is %i\\n\", MAX);","        return 2;","    }","    for (int i = 0; i < candidate_count; i++)","    {","        candidates[i] = argv[i + 1];","    }","","    // Clear graph of locked in pairs","    for (int i = 0; i < candidate_count; i++)","    {","        for (int j = 0; j < candidate_count; j++)","        {","            locked[i][j] = false;","        }","    }","","    pair_count = 0;","    int voter_count = get_int(\"Number of voters: \");","","    // Query for votes","    for (int i = 0; i < voter_count; i++)","    {","        // ranks[i] is voter's ith preference","        int ranks[candidate_count];     // will equal preferred candidate index","","        // Query for each rank","        for (int j = 0; j < candidate_count; j++)","        {","            string name = get_string(\"Rank %i: \", j + 1);","","            if (!vote(j, name, ranks))","            {","                printf(\"Invalid vote.\\n\");","                return 3;","            }","        }","","        record_preferences(ranks);              // one voter at a time","","        printf(\"\\n\");","    }","","    add_pairs();","    sort_pairs();","    lock_pairs();","    print_winner();","    return 0;","}","","// Update ranks given a new vote","bool vote(int rank, string name, int ranks[])","{","    for (int i = 0; i < candidate_count; i++)","    {","        if (strcmp(candidates[i], name) == 0)","        {","            ranks[rank] = i;","            return true;","        }","    }","    return false;","}","","// Update preferences given one voter's ranks","void record_preferences(int ranks[])","{","    for (int i = 0; i < 2; i++)","    {","        for (int j = 0; j < 3; j++)","        {","            if (i < j)","            {","                preferences[ranks[i]][ranks[j]]++;","            }","        }","    }","","    for (int i = 0; i < candidate_count; i++)","    {","        preferences[i][i] = 0;","    }","","    return;","}","","// Record pairs of candidates where one is preferred over the other","void add_pairs(void)","{","    for (int i = 0; i < candidate_count; i++)","    {","","        for (int j = 0; j < candidate_count; j++)","        {","            if (preferences[i][j] > preferences[j][i])","            {","                pairs[pair_count].winner = i;","                pairs[pair_count].loser = j;","                pair_count++;","            }","","        }","","    }","    return;","}","","// Sort pairs in decreasing order by strength of victory","void sort_pairs(void)","{","    for (int a = 0; a < pair_count; a++)","    {","        int max = 0;","        for (int i = 0; i < candidate_count; i++)","        {","            for (int j = i + 1; j < candidate_count; j++)","            {","                int margin = preferences[i][j] - preferences[j][i];","                if (margin > max)","                {","                    pairs[a].winner = i;","                    pairs[a].loser = j;","                    max = margin;","                }","            }","        }","        preferences[pairs[a].winner][pairs[a].loser] = 0;","    }","","}","","// Lock pairs into the candidate graph in order, without creating cycles","void lock_pairs(void)","{","    for (int i = 0; i < pair_count; i++)","    {","        if (!check_cycle(pairs[i].loser, pairs[i].winner))","        {","            locked[pairs[i].winner][pairs[i].loser] = true;","        }","    }","","    return;","}","","// Checks for cycle in the locked graph,","//by going through each candidate and checking each path and whether they return the same candidate","bool check_cycle(int from, int to)","{","    if (from == to)","    {","        return true;        // path is present hence cycle is present","    }","","    for (int i = 0; i < candidate_count; i++)","    {","        if (locked[from][i])            //checking for a path element by element (candidate by candidate)","        {","            return check_cycle(i, to);","        }","    }","    return false;               // cycle is not present","}","","// Print the winner of the election","void print_winner(void)","{","","    // Prints the source, where no arrows point to candidate","    for (int i = 0; i < candidate_count; i++)","    {","        for (int j = 0; j < candidate_count; j++)","        {","            if (!locked[i][j])","            {","                continue;","            }","            else","            {","                break;","            }","        }","        printf(\"%s\\n\", candidates[i]);","    }","","    return;","}"]}],[{"start":{"row":183,"column":0},"end":{"row":238,"column":1},"action":"remove","lines":["// Lock pairs into the candidate graph in order, without creating cycles","void lock_pairs(void)","{","    for (int i = 0; i < pair_count; i++)","    {","        if (!check_cycle(pairs[i].loser, pairs[i].winner))","        {","            locked[pairs[i].winner][pairs[i].loser] = true;","        }","    }","","    return;","}","","// Checks for cycle in the locked graph,","//by going through each candidate and checking each path and whether they return the same candidate","bool check_cycle(int from, int to)","{","    if (from == to)","    {","        return true;        // path is present hence cycle is present","    }","","    for (int i = 0; i < candidate_count; i++)","    {","        if (locked[from][i])            //checking for a path element by element (candidate by candidate)","        {","            return check_cycle(i, to);","        }","    }","    return false;               // cycle is not present","}","","// Print the winner of the election","void print_winner(void)","{","","    // Prints the source, where no arrows point to candidate","    for (int i = 0; i < candidate_count; i++)","    {","        for (int j = 0; j < candidate_count; j++)","        {","            if (!locked[i][j])","            {","                continue;","            }","            else","            {","                break;","            }","        }","        printf(\"%s\\n\", candidates[i]);","    }","","    return;","}"],"id":6},{"start":{"row":183,"column":0},"end":{"row":220,"column":1},"action":"insert","lines":["// Lock pairs into the candidate graph in order, without creating cycles","void lock_pairs(void)","{"," ","    // Lock all pairs","    for (int i = 0; i < pair_count; i++)","    {","        if (!check_cycle(pairs[i].loser, pairs[i].winner))  // lock path A --> B if B --> A does not exist","        {","            locked[pairs[i].winner][pairs[i].loser] = true;","        }","    }","    return;","}"," ","// A --> B forms a cycle if a path B --> A already exist","// check_cycle: checks if path 'from' --> 'to' exist or not","bool check_cycle(int from, int to)","{","    // Base Case 1: if path exist","    if (from == to)","    {","        return true;    // it forms a cycle","    }","    else","    {","        int i;","        for (i = 0; i < candidate_count; i++)","        {","            if (locked[from][i])    // next node is found","            {","                return check_cycle(i, to);","            }","        }"," ","        return false; // it does not form cycle","    }","}"]}],[{"start":{"row":0,"column":0},"end":{"row":220,"column":1},"action":"remove","lines":["#include <cs50.h>","#include <stdio.h>","#include <stdlib.h>","#include <string.h>","#include <ctype.h>","","// Max number of candidates","#define MAX 9","","// preferences[i][j] is number of voters who prefer i over j","int preferences[MAX][MAX];","","// locked[i][j] means i is locked in over j","bool locked[MAX][MAX];","","// Each pair has a winner, loser","typedef struct","{","    int winner;         // it is the candidate index who lead over the other candidate in the ith pair","    int loser;","}","pair;","","// Array of candidates","string candidates[MAX];","pair pairs[MAX * (MAX - 1) / 2];","","int pair_count;                 // total number of pairs","int candidate_count;","","// Function prototypes","bool vote(int rank, string name, int ranks[]);","void record_preferences(int ranks[]);","void add_pairs(void);","void sort_pairs(void);","void lock_pairs(void);","void print_winner(void);","bool check_cycle(int from, int to);","","int main(int argc, string argv[])","{","    // Check for invalid usage","    if (argc < 2)","    {","        printf(\"Usage: tideman [candidate ...]\\n\");","        return 1;","    }","","    // Populate array of candidates","    candidate_count = argc - 1;","    if (candidate_count > MAX)","    {","        printf(\"Maximum number of candidates is %i\\n\", MAX);","        return 2;","    }","    for (int i = 0; i < candidate_count; i++)","    {","        candidates[i] = argv[i + 1];","    }","","    // Clear graph of locked in pairs","    for (int i = 0; i < candidate_count; i++)","    {","        for (int j = 0; j < candidate_count; j++)","        {","            locked[i][j] = false;","        }","    }","","    pair_count = 0;","    int voter_count = get_int(\"Number of voters: \");","","    // Query for votes","    for (int i = 0; i < voter_count; i++)","    {","        // ranks[i] is voter's ith preference","        int ranks[candidate_count];     // will equal preferred candidate index","","        // Query for each rank","        for (int j = 0; j < candidate_count; j++)","        {","            string name = get_string(\"Rank %i: \", j + 1);","","            if (!vote(j, name, ranks))","            {","                printf(\"Invalid vote.\\n\");","                return 3;","            }","        }","","        record_preferences(ranks);              // one voter at a time","","        printf(\"\\n\");","    }","","    add_pairs();","    sort_pairs();","    lock_pairs();","    print_winner();","    return 0;","}","","// Update ranks given a new vote","bool vote(int rank, string name, int ranks[])","{","    for (int i = 0; i < candidate_count; i++)","    {","        if (strcmp(candidates[i], name) == 0)","        {","            ranks[rank] = i;","            return true;","        }","    }","    return false;","}","","// Update preferences given one voter's ranks","void record_preferences(int ranks[])","{","    for (int i = 0; i < 2; i++)","    {","        for (int j = 0; j < 3; j++)","        {","            if (i < j)","            {","                preferences[ranks[i]][ranks[j]]++;","            }","        }","    }","","    for (int i = 0; i < candidate_count; i++)","    {","        preferences[i][i] = 0;","    }","","    return;","}","","// Record pairs of candidates where one is preferred over the other","void add_pairs(void)","{","    for (int i = 0; i < candidate_count; i++)","    {","","        for (int j = 0; j < candidate_count; j++)","        {","            if (preferences[i][j] > preferences[j][i])","            {","                pairs[pair_count].winner = i;","                pairs[pair_count].loser = j;","                pair_count++;","            }","","        }","","    }","    return;","}","","// Sort pairs in decreasing order by strength of victory","void sort_pairs(void)","{","    for (int a = 0; a < pair_count; a++)","    {","        int max = 0;","        for (int i = 0; i < candidate_count; i++)","        {","            for (int j = i + 1; j < candidate_count; j++)","            {","                int margin = preferences[i][j] - preferences[j][i];","                if (margin > max)","                {","                    pairs[a].winner = i;","                    pairs[a].loser = j;","                    max = margin;","                }","            }","        }","        preferences[pairs[a].winner][pairs[a].loser] = 0;","    }","","}","","// Lock pairs into the candidate graph in order, without creating cycles","void lock_pairs(void)","{"," ","    // Lock all pairs","    for (int i = 0; i < pair_count; i++)","    {","        if (!check_cycle(pairs[i].loser, pairs[i].winner))  // lock path A --> B if B --> A does not exist","        {","            locked[pairs[i].winner][pairs[i].loser] = true;","        }","    }","    return;","}"," ","// A --> B forms a cycle if a path B --> A already exist","// check_cycle: checks if path 'from' --> 'to' exist or not","bool check_cycle(int from, int to)","{","    // Base Case 1: if path exist","    if (from == to)","    {","        return true;    // it forms a cycle","    }","    else","    {","        int i;","        for (i = 0; i < candidate_count; i++)","        {","            if (locked[from][i])    // next node is found","            {","                return check_cycle(i, to);","            }","        }"," ","        return false; // it does not form cycle","    }","}"],"id":7},{"start":{"row":0,"column":0},"end":{"row":238,"column":1},"action":"insert","lines":["#include <cs50.h>","#include <stdio.h>","#include <stdlib.h>","#include <string.h>","#include <ctype.h>","","// Max number of candidates","#define MAX 9","","// preferences[i][j] is number of voters who prefer i over j","int preferences[MAX][MAX];","","// locked[i][j] means i is locked in over j","bool locked[MAX][MAX];","","// Each pair has a winner, loser","typedef struct","{","    int winner;         // it is the candidate index who lead over the other candidate in the ith pair","    int loser;","}","pair;","","// Array of candidates","string candidates[MAX];","pair pairs[MAX * (MAX - 1) / 2];","","int pair_count;                 // total number of pairs","int candidate_count;","","// Function prototypes","bool vote(int rank, string name, int ranks[]);","void record_preferences(int ranks[]);","void add_pairs(void);","void sort_pairs(void);","void lock_pairs(void);","void print_winner(void);","bool check_cycle(int from, int to);","","int main(int argc, string argv[])","{","    // Check for invalid usage","    if (argc < 2)","    {","        printf(\"Usage: tideman [candidate ...]\\n\");","        return 1;","    }","","    // Populate array of candidates","    candidate_count = argc - 1;","    if (candidate_count > MAX)","    {","        printf(\"Maximum number of candidates is %i\\n\", MAX);","        return 2;","    }","    for (int i = 0; i < candidate_count; i++)","    {","        candidates[i] = argv[i + 1];","    }","","    // Clear graph of locked in pairs","    for (int i = 0; i < candidate_count; i++)","    {","        for (int j = 0; j < candidate_count; j++)","        {","            locked[i][j] = false;","        }","    }","","    pair_count = 0;","    int voter_count = get_int(\"Number of voters: \");","","    // Query for votes","    for (int i = 0; i < voter_count; i++)","    {","        // ranks[i] is voter's ith preference","        int ranks[candidate_count];     // will equal preferred candidate index","","        // Query for each rank","        for (int j = 0; j < candidate_count; j++)","        {","            string name = get_string(\"Rank %i: \", j + 1);","","            if (!vote(j, name, ranks))","            {","                printf(\"Invalid vote.\\n\");","                return 3;","            }","        }","","        record_preferences(ranks);              // one voter at a time","","        printf(\"\\n\");","    }","","    add_pairs();","    sort_pairs();","    lock_pairs();","    print_winner();","    return 0;","}","","// Update ranks given a new vote","bool vote(int rank, string name, int ranks[])","{","    for (int i = 0; i < candidate_count; i++)","    {","        if (strcmp(candidates[i], name) == 0)","        {","            ranks[rank] = i;","            return true;","        }","    }","    return false;","}","","// Update preferences given one voter's ranks","void record_preferences(int ranks[])","{","    for (int i = 0; i < 2; i++)","    {","        for (int j = 0; j < 3; j++)","        {","            if (i < j)","            {","                preferences[ranks[i]][ranks[j]]++;","            }","        }","    }","","    for (int i = 0; i < candidate_count; i++)","    {","        preferences[i][i] = 0;","    }","","    return;","}","","// Record pairs of candidates where one is preferred over the other","void add_pairs(void)","{","    for (int i = 0; i < candidate_count; i++)","    {","","        for (int j = 0; j < candidate_count; j++)","        {","            if (preferences[i][j] > preferences[j][i])","            {","                pairs[pair_count].winner = i;","                pairs[pair_count].loser = j;","                pair_count++;","            }","","        }","","    }","    return;","}","","// Sort pairs in decreasing order by strength of victory","void sort_pairs(void)","{","    for (int a = 0; a < pair_count; a++)","    {","        int max = 0;","        for (int i = 0; i < candidate_count; i++)","        {","            for (int j = i + 1; j < candidate_count; j++)","            {","                int margin = preferences[i][j] - preferences[j][i];","                if (margin > max)","                {","                    pairs[a].winner = i;","                    pairs[a].loser = j;","                    max = margin;","                }","            }","        }","        preferences[pairs[a].winner][pairs[a].loser] = 0;","    }","","}","","// Lock pairs into the candidate graph in order, without creating cycles","void lock_pairs(void)","{","    for (int i = 0; i < pair_count; i++)","    {","        if (!check_cycle(pairs[i].loser, pairs[i].winner))","        {","            locked[pairs[i].winner][pairs[i].loser] = true;","        }","    }","","    return;","}","","// Checks for cycle in the locked graph,","//by going through each candidate and checking each path and whether they return the same candidate","bool check_cycle(int from, int to)","{","    if (from == to)","    {","        return true;        // path is present hence cycle is present","    }","","    for (int i = 0; i < candidate_count; i++)","    {","        if (locked[from][i])            //checking for a path element by element (candidate by candidate)","        {","            return check_cycle(i, to);","        }","    }","    return false;               // cycle is not present","}","","// Print the winner of the election","void print_winner(void)","{","","    // Prints the source, where no arrows point to candidate","    for (int i = 0; i < candidate_count; i++)","    {","        for (int j = 0; j < candidate_count; j++)","        {","            if (!locked[i][j])","            {","                continue;","            }","            else","            {","                break;","            }","        }","        printf(\"%s\\n\", candidates[i]);","    }","","    return;","}"]}],[{"start":{"row":213,"column":0},"end":{"row":229,"column":1},"action":"remove","lines":["//checking for cycle","bool check_cycle(int n, int m)","{","    if (locked[m][n] == true)","    {","        return true;","    }","","    for (int i = 0; i < candidate_count; i++)","    {","        if (locked[i][n] == true)","        {","            check_cycle(i, m);","        }","    }","    return false;","}"],"id":10},{"start":{"row":213,"column":0},"end":{"row":230,"column":1},"action":"insert","lines":["//Can_reach recursive auxiliary function: returns true if a can reach b.","//a = initial winner, b = initial loser","bool loopcheck(int a, int b)","{","    if (locked[b][a] == true)","    {","        return true;","    }","","    for (int i = 0; i < candidate_count; i++)","    {","        if (locked[i][a] == true)","            {","            return loopcheck(i, b);","        }","    }","    return false;","}"]}],[{"start":{"row":0,"column":0},"end":{"row":238,"column":1},"action":"remove","lines":["#include <cs50.h>","#include <stdio.h>","#include <stdlib.h>","#include <string.h>","#include <ctype.h>","","// Max number of candidates","#define MAX 9","","// preferences[i][j] is number of voters who prefer i over j","int preferences[MAX][MAX];","","// locked[i][j] means i is locked in over j","bool locked[MAX][MAX];","","// Each pair has a winner, loser","typedef struct","{","    int winner;         // it is the candidate index who lead over the other candidate in the ith pair","    int loser;","}","pair;","","// Array of candidates","string candidates[MAX];","pair pairs[MAX * (MAX - 1) / 2];","","int pair_count;                 // total number of pairs","int candidate_count;","","// Function prototypes","bool vote(int rank, string name, int ranks[]);","void record_preferences(int ranks[]);","void add_pairs(void);","void sort_pairs(void);","void lock_pairs(void);","void print_winner(void);","bool check_cycle(int from, int to);","","int main(int argc, string argv[])","{","    // Check for invalid usage","    if (argc < 2)","    {","        printf(\"Usage: tideman [candidate ...]\\n\");","        return 1;","    }","","    // Populate array of candidates","    candidate_count = argc - 1;","    if (candidate_count > MAX)","    {","        printf(\"Maximum number of candidates is %i\\n\", MAX);","        return 2;","    }","    for (int i = 0; i < candidate_count; i++)","    {","        candidates[i] = argv[i + 1];","    }","","    // Clear graph of locked in pairs","    for (int i = 0; i < candidate_count; i++)","    {","        for (int j = 0; j < candidate_count; j++)","        {","            locked[i][j] = false;","        }","    }","","    pair_count = 0;","    int voter_count = get_int(\"Number of voters: \");","","    // Query for votes","    for (int i = 0; i < voter_count; i++)","    {","        // ranks[i] is voter's ith preference","        int ranks[candidate_count];     // will equal preferred candidate index","","        // Query for each rank","        for (int j = 0; j < candidate_count; j++)","        {","            string name = get_string(\"Rank %i: \", j + 1);","","            if (!vote(j, name, ranks))","            {","                printf(\"Invalid vote.\\n\");","                return 3;","            }","        }","","        record_preferences(ranks);              // one voter at a time","","        printf(\"\\n\");","    }","","    add_pairs();","    sort_pairs();","    lock_pairs();","    print_winner();","    return 0;","}","","// Update ranks given a new vote","bool vote(int rank, string name, int ranks[])","{","    for (int i = 0; i < candidate_count; i++)","    {","        if (strcmp(candidates[i], name) == 0)","        {","            ranks[rank] = i;","            return true;","        }","    }","    return false;","}","","// Update preferences given one voter's ranks","void record_preferences(int ranks[])","{","    for (int i = 0; i < 2; i++)","    {","        for (int j = 0; j < 3; j++)","        {","            if (i < j)","            {","                preferences[ranks[i]][ranks[j]]++;","            }","        }","    }","","    for (int i = 0; i < candidate_count; i++)","    {","        preferences[i][i] = 0;","    }","","    return;","}","","// Record pairs of candidates where one is preferred over the other","void add_pairs(void)","{","    for (int i = 0; i < candidate_count; i++)","    {","","        for (int j = 0; j < candidate_count; j++)","        {","            if (preferences[i][j] > preferences[j][i])","            {","                pairs[pair_count].winner = i;","                pairs[pair_count].loser = j;","                pair_count++;","            }","","        }","","    }","    return;","}","","// Sort pairs in decreasing order by strength of victory","void sort_pairs(void)","{","    for (int a = 0; a < pair_count; a++)","    {","        int max = 0;","        for (int i = 0; i < candidate_count; i++)","        {","            for (int j = i + 1; j < candidate_count; j++)","            {","                int margin = preferences[i][j] - preferences[j][i];","                if (margin > max)","                {","                    pairs[a].winner = i;","                    pairs[a].loser = j;","                    max = margin;","                }","            }","        }","        preferences[pairs[a].winner][pairs[a].loser] = 0;","    }","","}","","// Lock pairs into the candidate graph in order, without creating cycles","void lock_pairs(void)","{","    for (int i = 0; i < pair_count; i++)","    {","        if (!check_cycle(pairs[i].loser, pairs[i].winner))","        {","            locked[pairs[i].winner][pairs[i].loser] = true;","        }","    }","","    return;","}","","// Checks for cycle in the locked graph,","//by going through each candidate and checking each path and whether they return the same candidate","bool check_cycle(int from, int to)","{","    if (from == to)","    {","        return true;        // path is present hence cycle is present","    }","","    for (int i = 0; i < candidate_count; i++)","    {","        if (locked[from][i])            //checking for a path element by element (candidate by candidate)","        {","            return check_cycle(i, to);","        }","    }","    return false;               // cycle is not present","}","","// Print the winner of the election","void print_winner(void)","{","","    // Prints the source, where no arrows point to candidate","    for (int i = 0; i < candidate_count; i++)","    {","        for (int j = 0; j < candidate_count; j++)","        {","            if (!locked[i][j])","            {","                continue;","            }","            else","            {","                break;","            }","        }","        printf(\"%s\\n\", candidates[i]);","    }","","    return;","}"],"id":9},{"start":{"row":0,"column":0},"end":{"row":229,"column":1},"action":"insert","lines":["#include <cs50.h>","#include <stdio.h>","#include <string.h>","","// Max number of candidates","#define MAX 9","","// preferences[i][j] is number of voters who prefer i over j","int preferences[MAX][MAX];","","// locked[i][j] means i is locked in over j","bool locked[MAX][MAX];","","// Each pair has a winner, loser","typedef struct","{","    int winner;","    int loser;","}","pair;","","// Array of candidates","string candidates[MAX];","pair pairs[MAX * (MAX - 1) / 2];","","int pair_count;","int candidate_count;","","// Function prototypes","bool vote(int rank, string name, int ranks[]);","void record_preferences(int ranks[]);","void add_pairs(void);","void sort_pairs(void);","void lock_pairs(void);","void print_winner(void);","bool check_cycle(int n, int m);","","int main(int argc, string argv[])","{","    // Check for invalid usage","    if (argc < 2)","    {","        printf(\"Usage: tideman [candidate ...]\\n\");","        return 1;","    }","","    // Populate array of candidates","    candidate_count = argc - 1;","    if (candidate_count > MAX)","    {","        printf(\"Maximum number of candidates is %i\\n\", MAX);","        return 2;","    }","    for (int i = 0; i < candidate_count; i++)","    {","        candidates[i] = argv[i + 1];","    }","","    // Clear graph of locked in pairs","    for (int i = 0; i < candidate_count; i++)","    {","        for (int j = 0; j < candidate_count; j++)","        {","            locked[i][j] = false;","        }","    }","","    pair_count = 0;","    int voter_count = get_int(\"Number of voters: \");","","    // Query for votes","    for (int i = 0; i < voter_count; i++)","    {","        // ranks[i] is voter's ith preference","        int ranks[candidate_count];","","        // Query for each rank","        for (int j = 0; j < candidate_count; j++)","        {","            string name = get_string(\"Rank %i: \", j + 1);","","            if (!vote(j, name, ranks))","            {","                printf(\"Invalid vote.\\n\");","                return 3;","            }","        }","","        record_preferences(ranks);","","        printf(\"\\n\");","    }","","    add_pairs();","    sort_pairs();","    lock_pairs();","    print_winner();","    return 0;","}","","// Update ranks given a new vote","bool vote(int rank, string name, int ranks[])","{","    // TODO","    for (int i = 0; i < candidate_count; i++)","    {","        if (strcmp(candidates[i], name) == 0)","        {","            ranks[rank] = i;","            return true;","        }","    }","","    return false;","}","","// Update preferences given one voter's ranks","void record_preferences(int ranks[])","{","    // TODO","    for (int i = 0; i < candidate_count; i++)","    {","        for (int j = 1; j < candidate_count - i; j++)","        {","            preferences[ranks[i]][ranks[i + j]]++;","        }","    }","","    return;","}","","// Record pairs of candidates where one is preferred over the other","void add_pairs(void)","{","    // TODO","    for (int i = 0; i < candidate_count; i++)","    {","        for (int j = 0; j < candidate_count; j++)","        {","            if (preferences[i][j] > preferences[j][i])","            {","                pairs[pair_count].winner = i;","                pairs[pair_count].loser = j;","                pair_count++;","            }","        }","    }","","    return;","}","","// Sort pairs in decreasing order by strength of victory","void sort_pairs(void)","{","    // TODO","    pair k;","    for (int i = 0; i < pair_count; i++)","    {","        for (int j = i + 1; j < pair_count; j++)","        {","            if (preferences[pairs[i].winner][pairs[i].loser] < preferences[pairs[j].winner][pairs[j].loser])","            {","                //memcpy","                k = pairs[i];","                pairs[i] = pairs[j];","                pairs[j] = k;","            }","        }","    }","","    return;","}","","// Lock pairs into the candidate graph in order, without creating cycles","void lock_pairs(void)","{","    // TODO","    for (int i = 0; i < pair_count; i++)","    {","        if (!check_cycle(pairs[i].winner, pairs[i].loser))","        {","            locked[pairs[i].winner][pairs[i].loser] = true;","        }","    }","    return;","}","","// Print the winner of the election","void print_winner(void)","{","    // TODO","    for (int i = 0; i < candidate_count; i++)","    {","        bool source = true;","","        for (int j = 0; j < candidate_count; j++)","        {","            if (locked[j][i] == true)","            {","                source = false;","                break;","            }","        }","","        if (source == true)","        {","            printf(\"%s\\n\", candidates[i]);","        }","    }","","    return;","}","","//checking for cycle","bool check_cycle(int n, int m)","{","    if (locked[m][n] == true)","    {","        return true;","    }","","    for (int i = 0; i < candidate_count; i++)","    {","        if (locked[i][n] == true)","        {","            check_cycle(i, m);","        }","    }","    return false;","}"]}]]},"ace":{"folds":[],"scrolltop":0,"scrollleft":0,"selection":{"start":{"row":18,"column":26},"end":{"row":18,"column":26},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":0},"timestamp":1597026060495,"hash":"561e2ab9f18cb3ec5ad4d00eb4b6a86a41234060"}